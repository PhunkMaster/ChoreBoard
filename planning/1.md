### Thanks — great brief! Before I implement, here’s a concise design proposal and the key questions I need answered so we get this right on the first pass.

---

### High‑level solution outline
- Backend: Django app with Django Auth for users and roles (`admin`, `member`).
- Scheduling: compute daily/periodic due slots at midnight server time; auto‑assign pool chores at their configured distribution time (default `17:30`). Overdue flagging starts at the next midnight tick. Cron‑like schedules supported via `croniter`.
- Assignment model:
  - Fixed‑assignee chores never enter the pool.
  - Pool chores can be claimed (limit 1 per user per day). Unclaimed chores get force‑assigned at their distribution time using a fair rotation policy and constraints (avoid last period’s completer, respect eligibility lists for undesirable chores).
  - “Undesirable” chores rotate within a chore‑specific eligible subset (not necessarily all users).
  - “Difficult” chores: special tag driving points/rotation/UX (see questions below to finalize behavior).
- Points & streaks:
  - Per‑chore configurable points with splitting across multiple helpers.
  - Round to hundredths at the transaction level.
  - Weekly scoreboard resets Sunday midnight server time; admin converts points ➜ cash using a configurable rate; a special “tooltime” hint appears if no chores were overdue that week.
  - Streaks maintained by admin; optional automatic suggestion when a perfect week occurs.
- UI/UX (responsive dark theme):
  - Main board: sections for Assigned, Pool, Overdue; chore cards green if on‑time, red if overdue; show last completion time and last completer.
  - Leaderboard page (also linkable directly).
  - User detail pages with their points and recent completions.
  - Admin console: manage chores, users/eligibility, rotation groups, point conversions, weekly resets, undo actions, and logs.
- Auditing/logging:
  - Evaluation log: every schedule evaluation (midnight, distribution times, manual re-eval).
  - Action log: complete, undo, reassign, force-assign, claim, auto-assign.

---

### Proposed core data model (draft)
- `Chore`: name, description, tags (`undesirable`, `difficult`), frequency type (`daily`, `every_n_days`, `weekly`, `cron`), frequency params (`n`, `weekday`, `cron_expr`), default distribution time, fixed assignee (nullable), points, active flag.
- `ChoreEligibility`: chore ↔ many eligible users (for rotation/undesirable chores).
- `ChoreInstance`: represents a due occurrence (due window). Fields: `chore`, `period_start`, `period_end` (midnight to midnight), `due_at` (end), `is_overdue`, `status` (`pool`, `assigned`, `completed`), `assigned_to` (nullable), `forced_assigned_at` (nullable). One row per period.
- `Completion`: instance ↔ many users (M2M through) so multiple helpers can be recorded with optional shares.
- `CompletionShare`: `completion`, `user`, `share` (default equal), computed `points_awarded` (rounded to hundredths at time of award).
- `PointsLedger`: immutable transactions (+/-) per user, linked to completion/undo/admin adjustment; stores rounded `amount` and `reason`.
- `RotationState`: per chore (or group) bookkeeping to avoid assigning someone who did the previous period and to maintain fairness.
- `Streak`: per scope (user or household — see questions) with current count and history.
- `EvaluationLog` and `ActionLog`: timestamped JSON detail payloads for auditability.

---

### Key scheduling behaviors
- At midnight server time:
  - Close the previous period’s open instances; mark overdue if incomplete; generate new `ChoreInstance` rows for the new day/week/cron occurrences.
- At each chore’s distribution time (default `17:30`):
  - If still in pool, auto-assign using rotation/eligibility; do not pick last period’s completer unless fixed‑assignee or no other valid candidate.
- Claiming:
  - A user can claim at most 1 chore per server day; claims assign the instance immediately. Undo by admin restores prior state and restores claim allowance (see questions).

---

### Tech stack choices for background jobs
- Option A (simple): Windows Task Scheduler calls Django management commands at:
  - Midnight: `evaluate_periods`
  - Every minute: `check_and_distribute` (or at least at each unique distribution time)
- Option B (app‑internal): APScheduler inside Django. Simpler dev, but requires a persistent web process and careful deployment.
- Option C (robust): Celery + Redis with Celery Beat. Production‑ready, best for future growth.

Please pick A/B/C.

---

### Admin workflows
- Weekly close (Sunday midnight): system snapshots weekly totals; admin gets a “tooltime” banner if zero overdue events last week; admin runs conversion with a configurable `$ per point` rate and resets weekly points.
- Undo completion: restores instance state (pool/assigned) and posts negative ledger entries to revert points; does not penalize the user or count against claim limits.

---

### Implementation pages (MVP)
- `/` Board view (filter: pool, assigned, overdue; claim buttons respecting daily limits).
- `/leaderboard` (weekly and all-time tabs).
- `/u/<username>` user page with weekly points, all‑time points, recent completions.
- `/admin/…` Django Admin plus custom admin pages for: conversion/reset, logs, rotation setup.

---

### Clarifying questions (please answer all)
1) Hosting/runtime
- Where will this run in production (Windows, Linux, container)? Is a persistent worker acceptable? Choose background job Option A, B, or C above.

2) Users & auth
- Use Django’s built‑in users? Do you need SSO or just local accounts? How are admins designated (Django is_staff/superuser OK)?
- “Users assignable points is configurable”: should we maintain an explicit “eligible for points” flag per user? Any users to exclude from rotation/auto‑assignment even if they can earn points?

3) Schedules & time rules
- Confirm server timezone = `America/Chicago` (as in settings) and that all “midnight” logic follows that TZ even during DST changes.
- Cron expressions: second/minute/hour granularity (standard 5‑field)? Any need for per‑chore custom due time different from midnight? For weekly chores, which weekday/time are they due?
- For `every_n_days`, is the anchor the chore’s creation date or an explicit start date per chore?

4) Distribution (force‑assignment) at default `17:30`
- Per‑chore override time: yes? If not set, default to `17:30` server time. Confirm.
- Selection algorithm priority: is this order correct?
  1. Only consider chore’s eligible users (if specified); else consider all point‑eligible users.
  2. Exclude last period’s completer(s).
  3. Prefer users with fewest force‑assignments this week to balance load.
  4. Break ties randomly.
- If no eligible user remains after exclusions, should we allow assigning to last period’s completer as a fallback? Or leave unassigned and alert admin?

5) Claims
- Confirm: 1 claim per user per server day (resets at midnight server time).
- If a claimed chore is undone by admin, should the user’s daily claim allowance be restored?
- Can a user claim a chore that is fixed‑assignee for someone else? I assume “no.” But can they “help” on such chores (earn split points) without claiming?

6) Difficult & undesirable chores
- “Undesirable” controls rotation among a subset of users. Please confirm how the subset is defined: a chore‑specific eligible user list maintained by admin?
- “Difficult” — what behavior should it drive?
  - Extra UI emphasis only?
  - Bonus points multiplier?
  - Stricter rotation (e.g., never assign same user twice in a row across weeks)?

7) Points & rounding
- Point split among helpers: equal split by default? Do you want editable shares per completion (e.g., 30/70)?
- Rounding rule: round half up to 2 decimals at the ledger entry level. OK?
- Weekly conversion rate: what default `$ per point` should we start with? Is it constant or settable per week during conversion?
- Should negative adjustments (from undo) be visible in users’ point history?

8) Streaks
- Is the streak per household (global) or per user? The brief sounds global (“if all chores were completed on time that week”). Please confirm.
- When a week has any overdue chore, streak resets to 0 unless admin overrides — correct?

9) Overdue definition & visibility
- A chore becomes overdue at midnight if its instance was not completed in the previous period — correct?
- Overdue chores remain visible on the board until completed; once completed, do you still want the original overdue badge shown in history?

10) Logs & admin tools
- Any retention requirements for logs (e.g., 1 year)?
- Should admin be able to export CSV for points, completions, and logs?

11) UI/Frontend stack
- Preference for stack: Django templates + HTMX + Tailwind (fast, server‑rendered) vs React SPA? I recommend Django+HTMX+Tailwind for speed and simplicity.
- Dark theme: OK to use Tailwind with a prebuilt dark palette (e.g., DaisyUI dark) and custom green/red states?

12) Access control
- Should non‑logged‑in users see the board read‑only, or require login for everything?

13) Data migration
- Do you want to import any data from your current monopoly‑choreboard or grocy instances?

14) Extras (optional, for later)
- Notifications (email/Discord/SMS) when a chore goes overdue or is assigned.
- Anti‑hogging rules beyond 1 claim/day (e.g., cap weekly claims, prioritize under‑served users).

---

### Next step
Once you confirm the answers (especially job runner choice A/B/C and UI stack), I’ll scaffold the Django app, models, migrations, admin pages, and initial responsive dark UI, then wire up the scheduler and logs per your preferences.